1. Rate Limiting & DoS — Deeper Look
The /api/checkout endpoint has zero throttling. But the deeper problem is in storage.ts: each checkout request triggers stripe.products.list() + individual stripe.prices.list() calls in a loop. So a single request spawns 12 Stripe API calls (1 product list + 1 price lookup per product). An attacker hitting /api/checkout rapidly doesn't just abuse your server — it burns your Stripe API rate limit quota and could get your account flagged. The in-memory cache only helps after the first request within a 60-second window; under concurrent load, multiple cache misses happen simultaneously.

2. Error Handling — Deeper Look
The error handler in server/index.ts does this:

ts
res.status(status).json({ message });
throw err;  // ← throws AFTER responding
This throw err after res.json() does nothing useful to the client (headers already sent), but it crashes the async IIFE and will cause unhandled rejection warnings in Node. It also means stack traces from internal errors propagate upward with no guardrails. Combined with the fact that queryClient.ts has retry: false and staleTime: Infinity, a single failed product fetch on first load is permanent for that session — there's no automatic recovery.

3. queryClient — Critical Misconfiguration
staleTime: Infinity means product data never re-fetches for the lifetime of the browser session. If you update a product's price in Stripe, existing visitors will see the old price until they hard-reload. This conflicts directly with the cart sync logic in use-cart.tsx which refreshes products on every cart length change — those two systems are fighting each other: TanStack Query serves stale cached data while the cart hook bypasses it entirely with a raw fetch().

4. Duplicate apiRequest Function
client/src/lib/api.ts and client/src/lib/queryClient.ts both define an identical apiRequest function. The one in api.ts is never used anywhere (the cart hook uses raw fetch() and the query client uses its own getQueryFn). This is dead code that will confuse future developers.

5. Hero Section — Performance & Memory Leaks
All three banner images are loaded simultaneously on page load — every <img> inside the carousel map is rendered into the DOM with opacity: 0, meaning all three full-resolution images download immediately even though only one is visible. On a slow mobile connection, this wastes significant bandwidth.

The navigateTo function in the hero creates a DOM element on every click, appends it to document.body, and relies on a transitionend event to remove it. If the transition never fires (e.g., user has prefers-reduced-motion), the overlay div is never removed, leaking DOM nodes on every navigation.

The autoplay setInterval depends on next being in its dependency array, but next depends on current via useCallback. This means the interval is cleared and reset on every slide change, which is correct but slightly wasteful — a useRef pattern would be cleaner and more predictable.

6. Navigation — isCheckingOut Global State Leak
isCheckingOut comes from useCart() context. Both the Navigation cart sidebar checkout button AND every ProductCard on the page share the same isCheckingOut state. When one user clicks "Comprar Ahora" on any card, every single Buy Now button on the entire page disables simultaneously — including in the cart sidebar. This is intentional to prevent double-submission but is overly aggressive and creates a jarring UX where unrelated buttons freeze.

7. Products Page — Category Filter Mismatch
The products page defines categories including "cuidado" and "manos", but the storage.ts mapper only recognizes category and additionalCategories from Stripe metadata, and the seed script assigns categories like unisex, sport, teens, travel. There are no products tagged cuidado or manos — those filter options will always return empty results, silently misleading users.

8. Footer — Two Issues
"Términos" link is fake — It's a <span> styled like a link with no href. There is no Terms of Service page, no route, and no file for it. This is a legal compliance gap — an e-commerce site selling to Mexican consumers is required to have visible Términos y Condiciones under PROFECO regulations.

Hardcoded product slug in footer — "/productos/eco-traveler-kit-de-viaje-natural-desodorantes-limpiador-de-manos-jabon" is hardcoded. If that product's slug changes in Stripe metadata, the footer link silently 404s with no warning.

9. SEO Component — Incomplete
The SEO component never passes og:image. Even though the prop exists, no page actually provides it — every call just omits ogImage. This means all social media link previews (WhatsApp shares, Facebook shares) will show no image, which is a major conversion killer for a Mexican market brand that drives traffic via WhatsApp. The BASE_URL is also hardcoded in the component itself, meaning if the domain ever changes, it must be updated in at least 3 separate places (seo.tsx, routes.ts sitemap, index.html canonical).

10. index.html — Font Ghost Load
The index.html preloads Nunito from Google Fonts, but the Tailwind config and design system specify Playfair Display + Inter as the actual fonts. Nunito is loaded but never applied anywhere — it's a wasted DNS lookup, network request, and render-blocking resource on every page load.

11. Drizzle / Database — Orphaned Config
drizzle.config.ts points to ./shared/schema.ts as the schema source, but shared/schema.ts contains only Zod validation schemas and TypeScript interfaces — no Drizzle table definitions (pgTable, text(), integer() etc.). Running drizzle-kit push would produce empty migrations. The database is never actually used by the app (products come from Stripe), making the entire Drizzle/Neon setup dead infrastructure that adds complexity without function.